<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notebook Entry</title>
    <link rel="alternate" type="application/json" title="Notebook index" href="notebooks/notebook-index.json">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="zotero-config.js"></script>
    <style>
        html {
            background-color: #ffffff;
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #ffffff;
            color: #333;
            overflow-x: hidden;
        }
        h1, h2 { 
            color: #333;
            font-weight: 400;
        }
        .container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            padding: 48px clamp(20px, 6vw, 40px) 96px;
        }
        .nav-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
            margin-bottom: 14px;
        }
        .back-link {
            margin-bottom: 0;
        }
        .back-link a {
            color: #0077cc;
            text-decoration: none;
        }
        .back-link a:hover {
            text-decoration: underline;
        }
        .entry-nav {
            display: flex;
            gap: 12px;
            flex: 0 0 auto;
        }
        .entry-nav a {
            color: #0077cc;
            text-decoration: none;
            font-size: 14px;
        }
        .entry-nav a:hover {
            text-decoration: underline;
        }
        .entry-date {
            color: #888;
            font-size: 14px;
            margin-bottom: 20px;
        }
        #content {
            color: #333;
            line-height: 1.8;
        }
        #content h1 {
            margin-top: 30px;
            font-size: 28px;
        }
        #content h2 {
            margin-top: 25px;
            font-size: 22px;
        }
        #content h3 {
            margin-top: 20px;
            font-size: 18px;
            font-weight: 500;
        }
        #content a {
            color: #0077cc;
        }
        #content code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: Monaco, Consolas, monospace;
            font-size: 14px;
        }
        #content pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        #content .math-display,
        #content .katex-display {
            overflow-x: auto;
            overflow-y: hidden;
            padding: 0.4em 0;
        }
        #content .katex {
            font-size: 1.02em;
        }
        #content blockquote {
            border-left: 4px solid #ddd;
            margin-left: 0;
            padding-left: 20px;
            color: #666;
        }
        #content ul, #content ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        #content li {
            margin: 8px 0;
        }
        .references {
            margin-top: 48px;
            padding-top: 24px;
            border-top: 1px solid #eee;
        }
        .references h2 {
            margin: 0 0 14px;
            font-size: 18px;
            font-weight: 500;
        }
        .references ol {
            margin: 0;
            padding-left: 22px;
        }
        .references li {
            margin: 10px 0;
        }
        .references .ref-links {
            margin-top: 6px;
            font-size: 14px;
            color: #666;
        }
        .references .ref-links a {
            color: #0077cc;
            text-decoration: none;
            margin-right: 12px;
        }
        .references .ref-links a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-row">
            <div class="back-link">
                <a href="notebooks.html">← All notebooks</a>
            </div>
            <div class="entry-nav" aria-label="Notebook navigation">
                <a id="nav-newer" href="notebooks.html" style="display: none;">← Newer</a>
                <a id="nav-older" href="notebooks.html" style="display: none;">Older →</a>
            </div>
        </div>
        <div id="entry-metadata"></div>
        <div id="content" aria-live="polite">
            <p style="color: #888;">Loading...</p>
        </div>
        <noscript>
            <section aria-label="Notebook access for non-JavaScript agents" style="margin-top: 24px; color: #555;">
                <p>JavaScript is required to render the notebook in this viewer. You can still access every entry by opening the Markdown files directly.</p>
                <p>The <a href="notebooks/notebook-index.json">machine-readable notebook index</a> lists all available entries. Copy the <code>path</code> value into the browser address bar, for example <code>notebooks/2025-10-02-autoformalization-agents.md</code>, to read the raw Markdown.</p>
            </section>
        </noscript>
    </div>

    <script>
        function escapeHtml(value) {
            return String(value || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function setupMarkedMath() {
            if (!window.marked || typeof window.marked.use !== 'function') {
                return;
            }

            function isProbablyInlineMath(text) {
                const t = String(text || '');
                if (!t) {
                    return false;
                }
                if (/^[0-9][0-9,.\s]*$/.test(t)) {
                    // Avoid turning $100 into math.
                    return false;
                }
                if (/\\|_|\\^|\\{|\\}|\\\\/.test(t)) {
                    return true;
                }
                if (/^[A-Za-z]$/.test(t)) {
                    return true;
                }
                // Equations/expressions.
                if (/[A-Za-z]/.test(t) && /[=<>+\-*/]/.test(t)) {
                    return true;
                }
                return false;
            }

            marked.use({
                extensions: [
                    {
                        name: 'mathBlock',
                        level: 'block',
                        start(src) {
                            const idx = src.indexOf('$$');
                            return idx >= 0 ? idx : undefined;
                        },
                        tokenizer(src) {
                            const match = src.match(/^\$\$\s*\n([\s\S]*?)\n\$\$\s*(?:\n|$)/);
                            if (!match) {
                                return;
                            }
                            return {
                                type: 'mathBlock',
                                raw: match[0],
                                text: match[1]
                            };
                        },
                        renderer(token) {
                            return `<div class="math-display">${escapeHtml(token.text)}</div>\n`;
                        }
                    },
                    {
                        name: 'mathInline',
                        level: 'inline',
                        start(src) {
                            const idx = src.indexOf('$');
                            return idx >= 0 ? idx : undefined;
                        },
                        tokenizer(src) {
                            if (!src || src[0] !== '$' || src.startsWith('$$')) {
                                return;
                            }
                            const match = src.match(/^\$([^\n$]+?)\$/);
                            if (!match) {
                                return;
                            }
                            const text = match[1];
                            if (!isProbablyInlineMath(text)) {
                                return;
                            }
                            return {
                                type: 'mathInline',
                                raw: match[0],
                                text
                            };
                        },
                        renderer(token) {
                            return `<span class="math-inline">${escapeHtml(token.text)}</span>`;
                        }
                    }
                ]
            });
        }

        function renderKatexMath(rootEl) {
            if (!rootEl || !window.katex || typeof window.katex.render !== 'function') {
                return;
            }
            const nodes = rootEl.querySelectorAll('.math-display, .math-inline');
            for (const node of nodes) {
                const tex = String(node.textContent || '').trim();
                if (!tex) {
                    continue;
                }
                const displayMode = node.classList.contains('math-display');
                try {
                    window.katex.render(tex, node, {
                        displayMode,
                        throwOnError: false
                    });
                } catch (error) {
                    console.warn('KaTeX render failed:', error);
                }
            }
        }

        setupMarkedMath();

        function normalizeDoi(raw) {
            const trimmed = String(raw || '').trim();
            if (!trimmed) {
                return '';
            }
            return trimmed
                .replace(/^https?:\/\/(dx\.)?doi\.org\//i, '')
                .toLowerCase();
        }

        function doiToUrl(raw) {
            const doi = normalizeDoi(raw);
            if (!doi) {
                return '';
            }
            const encoded = encodeURIComponent(doi).replace(/%2F/g, '/');
            return `https://doi.org/${encoded}`;
        }

        function normalizeExternalUrl(raw) {
            const trimmed = String(raw || '').trim();
            if (!trimmed) {
                return '';
            }
            if (/^https?:\/\//i.test(trimmed)) {
                return trimmed;
            }
            return '';
        }

        function formatDateIso(isoDate) {
            const raw = String(isoDate || '').trim();
            if (!/^\d{4}-\d{2}-\d{2}$/.test(raw)) {
                return raw;
            }
            return new Date(raw).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        let notebookIndexPromise = null;

        function fetchNotebookIndex() {
            if (notebookIndexPromise) {
                return notebookIndexPromise;
            }

            notebookIndexPromise = fetch('notebooks/notebook-index.json', { cache: 'no-store' })
                .then((response) => {
                    if (!response.ok) {
                        throw new Error(`Notebook index fetch failed (${response.status})`);
                    }
                    return response.json();
                })
                .then((data) => {
                    const entries = Array.isArray(data && data.entries) ? data.entries.slice() : [];
                    entries.sort((a, b) => {
                        const dateA = a.date || '';
                        const dateB = b.date || '';
                        if (dateA && dateB && dateA !== dateB) {
                            return dateB.localeCompare(dateA);
                        }
                        if (dateA && !dateB) {
                            return -1;
                        }
                        if (!dateA && dateB) {
                            return 1;
                        }
                        const titleA = a.title || '';
                        const titleB = b.title || '';
                        return titleA.localeCompare(titleB);
                    });
                    return entries;
                });

            return notebookIndexPromise;
        }

        function findNotebookIndexEntry(entries, entryPath) {
            const normalized = String(entryPath || '').replace(/^\/+/, '');
            let index = entries.findIndex((e) => e && e.path === normalized);
            if (index !== -1) {
                return index;
            }
            const filename = normalized.split('/').pop();
            index = entries.findIndex((e) => e && typeof e.path === 'string' && e.path.split('/').pop() === filename);
            return index;
        }

        function setNavLink(el, entry, label) {
            if (!el) {
                return;
            }
            if (!entry || !entry.path) {
                el.style.display = 'none';
                el.removeAttribute('href');
                return;
            }
            el.style.display = '';
            el.href = `notebook-viewer.html?entry=${encodeURIComponent(entry.path)}`;
            el.textContent = label;
            el.title = entry.title || '';
        }

        function renderNotebookMetadata(entry, fallbackDateText) {
            const metadataDiv = document.getElementById('entry-metadata');
            if (!metadataDiv) {
                return;
            }

            metadataDiv.innerHTML = '';
            const p = document.createElement('p');
            p.className = 'entry-date';

            function addSep() {
                p.appendChild(document.createTextNode(' · '));
            }

            const dateText = entry && entry.date ? formatDateIso(entry.date) : String(fallbackDateText || '').trim();
            if (dateText) {
                p.appendChild(document.createTextNode(dateText));
            }

            if (entry && entry.collection) {
                if (p.childNodes.length > 0) {
                    addSep();
                }
                const a = document.createElement('a');
                a.href = `notebooks.html?collection=${encodeURIComponent(entry.collection)}`;
                a.textContent = entry.collection;
                p.appendChild(a);
            }

            if (entry && Array.isArray(entry.tags) && entry.tags.length > 0) {
                if (p.childNodes.length > 0) {
                    addSep();
                }
                const span = document.createElement('span');
                for (let i = 0; i < entry.tags.length; i++) {
                    const tag = String(entry.tags[i] || '').trim();
                    if (!tag) {
                        continue;
                    }
                    if (span.childNodes.length > 0) {
                        span.appendChild(document.createTextNode(', '));
                    }
                    const a = document.createElement('a');
                    a.href = `notebooks.html?tag=${encodeURIComponent(tag)}`;
                    a.textContent = tag;
                    span.appendChild(a);
                }
                p.appendChild(span);
            }

            if (entry && entry.path) {
                addSep();
                const a = document.createElement('a');
                a.href = entry.path;
                a.target = '_blank';
                a.rel = 'noopener noreferrer';
                a.textContent = 'md';
                p.appendChild(a);
            }

            metadataDiv.appendChild(p);
        }

        function enhanceNotebookContext(entryPath, fallbackDateText) {
            fetchNotebookIndex()
                .then((entries) => {
                    const idx = findNotebookIndexEntry(entries, entryPath);
                    if (idx === -1) {
                        return;
                    }
                    const entry = entries[idx];
                    const newer = idx > 0 ? entries[idx - 1] : null;
                    const older = idx + 1 < entries.length ? entries[idx + 1] : null;

                    renderNotebookMetadata(entry, fallbackDateText);
                    setNavLink(document.getElementById('nav-newer'), newer, '← Newer');
                    setNavLink(document.getElementById('nav-older'), older, 'Older →');
                })
                .catch((error) => {
                    console.warn('Unable to enhance notebook context:', error);
                });
        }

        function getZoteroConfig() {
            const base = window.ZOTERO_SITE_CONFIG || {};
            const params = new URLSearchParams(window.location.search);
            return {
                groupId: params.get('group') || base.groupId || '',
                collectionKey: params.get('collection') || base.collectionKey || '',
                style: params.get('style') || base.style || 'apa'
            };
        }

        function isZoteroConfigured(config) {
            return /^\d+$/.test(String(config.groupId || '')) && /^[A-Za-z0-9]{8}$/.test(String(config.collectionKey || ''));
        }

        function zoteroSnapshotMatchesConfig(snapshot, config) {
            if (!snapshot || typeof snapshot !== 'object') {
                return false;
            }
            const source = snapshot.source && typeof snapshot.source === 'object' ? snapshot.source : null;
            if (!source) {
                return false;
            }
            return String(source.group_id || '') === String(config.groupId || '')
                && String(source.collection_key || '') === String(config.collectionKey || '')
                && String(source.style || '') === String(config.style || '');
        }

        async function fetchZoteroSnapshot(config) {
            const response = await fetch('zotero/library-items.json', { cache: 'no-store' });
            if (!response.ok) {
                return null;
            }
            const snapshot = await response.json();
            if (!zoteroSnapshotMatchesConfig(snapshot, config)) {
                return null;
            }
            return Array.isArray(snapshot.items) ? snapshot.items : [];
        }

        async function fetchZoteroItems(config) {
            const items = [];
            const pageSize = 100;
            let start = 0;

            while (true) {
                const url = new URL(`https://api.zotero.org/groups/${config.groupId}/collections/${config.collectionKey}/items/top`);
                url.search = new URLSearchParams({
                    v: '3',
                    format: 'json',
                    include: 'data,bib',
                    style: config.style,
                    linkwrap: '1',
                    limit: String(pageSize),
                    start: String(start)
                }).toString();

                const response = await fetch(url.toString(), { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Zotero API error (${response.status})`);
                }
                const batch = await response.json();
                if (!Array.isArray(batch) || batch.length === 0) {
                    break;
                }
                items.push(...batch);
                if (batch.length < pageSize) {
                    break;
                }
                start += batch.length;
            }

            return items;
        }

        function clearReferences() {
            const existing = document.getElementById('references');
            if (existing) {
                existing.remove();
            }
        }

        function extractCitationsAndRewriteLinks(contentEl) {
            const citations = [];
            const seen = new Set();

            const links = contentEl.querySelectorAll('a[href]');
            for (const a of links) {
                const rawHref = String(a.getAttribute('href') || '').trim();
                const doiMatch = rawHref.match(/^doi:(.+)$/i);
                const zoteroMatch = rawHref.match(/^zotero:([A-Za-z0-9]+)$/i);

                if (doiMatch) {
                    const doi = normalizeDoi(doiMatch[1]);
                    if (!doi) {
                        continue;
                    }
                    const key = `doi:${doi}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        citations.push({ type: 'doi', id: doi });
                    }
                    const href = doiToUrl(doi);
                    if (href) {
                        a.setAttribute('href', href);
                        a.setAttribute('target', '_blank');
                        a.setAttribute('rel', 'noopener noreferrer');
                    }
                } else if (zoteroMatch) {
                    const zoteroKey = String(zoteroMatch[1] || '').trim();
                    if (!zoteroKey) {
                        continue;
                    }
                    const key = `zotero:${zoteroKey}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        citations.push({ type: 'zotero', id: zoteroKey });
                    }
                    a.setAttribute('href', `library.html#z-${zoteroKey}`);
                    a.setAttribute('target', '_blank');
                    a.setAttribute('rel', 'noopener noreferrer');
                }
            }

            return citations;
        }

        async function renderReferences(citations) {
            clearReferences();
            if (!Array.isArray(citations) || citations.length === 0) {
                return;
            }

            const contentEl = document.getElementById('content');
            const section = document.createElement('section');
            section.id = 'references';
            section.className = 'references';
            section.innerHTML = '<h2>References</h2><p style="color: #888;">Loading...</p>';
            contentEl.insertAdjacentElement('afterend', section);

            const config = getZoteroConfig();
            const zoteroByKey = new Map();
            const zoteroByDoi = new Map();

            if (isZoteroConfigured(config)) {
                try {
                    let items = null;
                    try {
                        items = await fetchZoteroSnapshot(config);
                    } catch (error) {
                        items = null;
                    }
                    if (!items) {
                        items = await fetchZoteroItems(config);
                    }
                    for (const item of items) {
                        if (!item) {
                            continue;
                        }
                        if (item.key) {
                            zoteroByKey.set(item.key, item);
                        }
                        const doi = normalizeDoi(item.data && (item.data.DOI || item.data.doi));
                        if (doi) {
                            zoteroByDoi.set(doi, item);
                        }
                    }
                } catch (error) {
                    console.warn('Unable to fetch Zotero items for references:', error);
                }
            }

            section.innerHTML = '<h2>References</h2>';
            const ol = document.createElement('ol');

            for (const ref of citations) {
                const li = document.createElement('li');

                let item = null;
                if (ref.type === 'zotero') {
                    item = zoteroByKey.get(ref.id) || null;
                } else if (ref.type === 'doi') {
                    item = zoteroByDoi.get(ref.id) || null;
                }

                if (item && typeof item.bib === 'string' && item.bib.trim()) {
                    li.innerHTML = item.bib;
                } else if (ref.type === 'doi') {
                    const href = doiToUrl(ref.id);
                    li.innerHTML = href ? `<a href="${href}" target="_blank" rel="noopener noreferrer">${ref.id}</a>` : ref.id;
                } else if (ref.type === 'zotero') {
                    li.innerHTML = `<a href="library.html#z-${ref.id}" target="_blank" rel="noopener noreferrer">${ref.id}</a>`;
                } else {
                    li.textContent = String(ref.id || '');
                }

                const linksDiv = document.createElement('div');
                linksDiv.className = 'ref-links';

                if (ref.type === 'zotero') {
                    const a = document.createElement('a');
                    a.href = `library.html#z-${ref.id}`;
                    a.target = '_blank';
                    a.rel = 'noopener noreferrer';
                    a.textContent = 'Library';
                    linksDiv.appendChild(a);
                }

                if (ref.type === 'doi') {
                    const href = doiToUrl(ref.id);
                    if (href) {
                        const a = document.createElement('a');
                        a.href = href;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        a.textContent = 'DOI';
                        linksDiv.appendChild(a);
                    }
                } else if (item && item.data) {
                    const urlHref = normalizeExternalUrl(item.data.url || '');
                    const doiHref = doiToUrl(item.data.DOI || item.data.doi || '');
                    if (urlHref && urlHref !== doiHref) {
                        const a = document.createElement('a');
                        a.href = urlHref;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        a.textContent = 'URL';
                        linksDiv.appendChild(a);
                    }
                    if (doiHref) {
                        const a = document.createElement('a');
                        a.href = doiHref;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        a.textContent = 'DOI';
                        linksDiv.appendChild(a);
                    }
                }

                if (linksDiv.childNodes.length > 0) {
                    li.appendChild(linksDiv);
                }

                ol.appendChild(li);
            }

            section.appendChild(ol);
        }

        async function loadEntry() {
            const params = new URLSearchParams(window.location.search);
            const entryPath = params.get('entry');

            if (!entryPath) {
                document.getElementById('content').innerHTML = '<p style="color: #888;">No entry specified.</p>';
                clearReferences();
                return;
            }

            try {
                const candidates = [];
                candidates.push(entryPath);
                if (window.location.hostname === 'jswachter.github.io') {
                    const filename = entryPath.split('/').pop();
                    candidates.push(`https://raw.githubusercontent.com/jswachter/jswachter.github.io/main/notebooks/${filename}`);
                }

                let text = '';
                let lastError = null;
                for (const url of candidates) {
                    try {
                        const response = await fetch(url, { cache: 'no-store' });
                        if (!response.ok) {
                            lastError = new Error(`Fetch failed (${response.status})`);
                            continue;
                        }
                        text = await response.text();
                        lastError = null;
                        break;
                    } catch (error) {
                        lastError = error;
                    }
                }
                if (lastError) {
                    throw lastError;
                }

                // Parse frontmatter
                const lines = text.split('\n');
                let title = '';
                let date = '';
                let rawDate = '';
                let contentStart = 0;

                if (lines[0] === '---') {
                    let i = 1;
                    while (i < lines.length && lines[i] !== '---') {
                        if (lines[i].startsWith('title:')) {
                            title = lines[i].substring(6).trim();
                        } else if (lines[i].startsWith('date:')) {
                            rawDate = lines[i].substring(5).trim();
                            date = formatDateIso(rawDate);
                        }
                        i++;
                    }
                    contentStart = i + 1;
                }

                // Update page title
                if (title) {
                    document.title = title + ' - Notebook';
                }

                // Show metadata
                const metadataDiv = document.getElementById('entry-metadata');
                if (date) {
                    metadataDiv.innerHTML = `<p class="entry-date">${date}</p>`;
                }

                // Render markdown content
                const markdownContent = lines.slice(contentStart).join('\n');
                const htmlContent = marked.parse(markdownContent);
                const contentEl = document.getElementById('content');
                contentEl.innerHTML = htmlContent;

                renderKatexMath(contentEl);

                const citations = extractCitationsAndRewriteLinks(contentEl);
                renderReferences(citations);

                enhanceNotebookContext(entryPath, date || rawDate);
            } catch (error) {
                console.error('Error loading entry:', error);
                document.getElementById('content').innerHTML = '<p style="color: #888;">Unable to load entry.</p>';
                clearReferences();
            }
        }

        // Load entry when page loads
        loadEntry();
    </script>
</body>
</html>
