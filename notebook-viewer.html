<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Notebook Entry</title>
    <link rel="alternate" type="application/json" title="Notebook index" href="notebooks/notebook-index.json">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="zotero-config.js"></script>
    <style>
        html {
            background-color: #ffffff;
            box-sizing: border-box;
        }
        *, *::before, *::after {
            box-sizing: inherit;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 0;
            line-height: 1.6;
            background-color: #ffffff;
            color: #333;
            overflow-x: hidden;
        }
        h1, h2 { 
            color: #333;
            font-weight: 400;
        }
        .container {
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            padding: 48px clamp(20px, 6vw, 40px) 96px;
        }
        .back-link {
            margin-bottom: 20px;
        }
        .back-link a {
            color: #0077cc;
            text-decoration: none;
        }
        .back-link a:hover {
            text-decoration: underline;
        }
        .entry-date {
            color: #888;
            font-size: 14px;
            margin-bottom: 20px;
        }
        #content {
            color: #333;
            line-height: 1.8;
        }
        #content h1 {
            margin-top: 30px;
            font-size: 28px;
        }
        #content h2 {
            margin-top: 25px;
            font-size: 22px;
        }
        #content h3 {
            margin-top: 20px;
            font-size: 18px;
            font-weight: 500;
        }
        #content a {
            color: #0077cc;
        }
        #content code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: Monaco, Consolas, monospace;
            font-size: 14px;
        }
        #content pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        #content blockquote {
            border-left: 4px solid #ddd;
            margin-left: 0;
            padding-left: 20px;
            color: #666;
        }
        #content ul, #content ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        #content li {
            margin: 8px 0;
        }
        .references {
            margin-top: 48px;
            padding-top: 24px;
            border-top: 1px solid #eee;
        }
        .references h2 {
            margin: 0 0 14px;
            font-size: 18px;
            font-weight: 500;
        }
        .references ol {
            margin: 0;
            padding-left: 22px;
        }
        .references li {
            margin: 10px 0;
        }
        .references .ref-links {
            margin-top: 6px;
            font-size: 14px;
            color: #666;
        }
        .references .ref-links a {
            color: #0077cc;
            text-decoration: none;
            margin-right: 12px;
        }
        .references .ref-links a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="back-link">
            <a href="notebooks.html">‚Üê All notebooks</a>
        </div>
        <div id="entry-metadata"></div>
        <div id="content" aria-live="polite">
            <p style="color: #888;">Loading...</p>
        </div>
        <noscript>
            <section aria-label="Notebook access for non-JavaScript agents" style="margin-top: 24px; color: #555;">
                <p>JavaScript is required to render the notebook in this viewer. You can still access every entry by opening the Markdown files directly.</p>
                <p>The <a href="notebooks/notebook-index.json">machine-readable notebook index</a> lists all available entries. Copy the <code>path</code> value into the browser address bar, for example <code>notebooks/2025-10-02-autoformalization-agents.md</code>, to read the raw Markdown.</p>
            </section>
        </noscript>
    </div>

    <script>
        function normalizeDoi(raw) {
            const trimmed = String(raw || '').trim();
            if (!trimmed) {
                return '';
            }
            return trimmed
                .replace(/^https?:\/\/(dx\.)?doi\.org\//i, '')
                .toLowerCase();
        }

        function doiToUrl(raw) {
            const doi = normalizeDoi(raw);
            if (!doi) {
                return '';
            }
            const encoded = encodeURIComponent(doi).replace(/%2F/g, '/');
            return `https://doi.org/${encoded}`;
        }

        function normalizeExternalUrl(raw) {
            const trimmed = String(raw || '').trim();
            if (!trimmed) {
                return '';
            }
            if (/^https?:\/\//i.test(trimmed)) {
                return trimmed;
            }
            return '';
        }

        function getZoteroConfig() {
            const base = window.ZOTERO_SITE_CONFIG || {};
            const params = new URLSearchParams(window.location.search);
            return {
                groupId: params.get('group') || base.groupId || '',
                collectionKey: params.get('collection') || base.collectionKey || '',
                style: params.get('style') || base.style || 'apa'
            };
        }

        function isZoteroConfigured(config) {
            return /^\d+$/.test(String(config.groupId || '')) && /^[A-Za-z0-9]{8}$/.test(String(config.collectionKey || ''));
        }

        async function fetchZoteroItems(config) {
            const items = [];
            const pageSize = 100;
            let start = 0;

            while (true) {
                const url = new URL(`https://api.zotero.org/groups/${config.groupId}/collections/${config.collectionKey}/items/top`);
                url.search = new URLSearchParams({
                    v: '3',
                    format: 'json',
                    include: 'data,bib',
                    style: config.style,
                    linkwrap: '1',
                    limit: String(pageSize),
                    start: String(start)
                }).toString();

                const response = await fetch(url.toString(), { cache: 'no-store' });
                if (!response.ok) {
                    throw new Error(`Zotero API error (${response.status})`);
                }
                const batch = await response.json();
                if (!Array.isArray(batch) || batch.length === 0) {
                    break;
                }
                items.push(...batch);
                if (batch.length < pageSize) {
                    break;
                }
                start += batch.length;
            }

            return items;
        }

        function clearReferences() {
            const existing = document.getElementById('references');
            if (existing) {
                existing.remove();
            }
        }

        function extractCitationsAndRewriteLinks(contentEl) {
            const citations = [];
            const seen = new Set();

            const links = contentEl.querySelectorAll('a[href]');
            for (const a of links) {
                const rawHref = String(a.getAttribute('href') || '').trim();
                const doiMatch = rawHref.match(/^doi:(.+)$/i);
                const zoteroMatch = rawHref.match(/^zotero:([A-Za-z0-9]+)$/i);

                if (doiMatch) {
                    const doi = normalizeDoi(doiMatch[1]);
                    if (!doi) {
                        continue;
                    }
                    const key = `doi:${doi}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        citations.push({ type: 'doi', id: doi });
                    }
                    const href = doiToUrl(doi);
                    if (href) {
                        a.setAttribute('href', href);
                        a.setAttribute('target', '_blank');
                        a.setAttribute('rel', 'noopener noreferrer');
                    }
                } else if (zoteroMatch) {
                    const zoteroKey = String(zoteroMatch[1] || '').trim();
                    if (!zoteroKey) {
                        continue;
                    }
                    const key = `zotero:${zoteroKey}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        citations.push({ type: 'zotero', id: zoteroKey });
                    }
                    a.setAttribute('href', `library.html#z-${zoteroKey}`);
                    a.setAttribute('target', '_blank');
                    a.setAttribute('rel', 'noopener noreferrer');
                }
            }

            return citations;
        }

        async function renderReferences(citations) {
            clearReferences();
            if (!Array.isArray(citations) || citations.length === 0) {
                return;
            }

            const contentEl = document.getElementById('content');
            const section = document.createElement('section');
            section.id = 'references';
            section.className = 'references';
            section.innerHTML = '<h2>References</h2><p style="color: #888;">Loading...</p>';
            contentEl.insertAdjacentElement('afterend', section);

            const config = getZoteroConfig();
            const zoteroByKey = new Map();
            const zoteroByDoi = new Map();

            if (isZoteroConfigured(config)) {
                try {
                    const items = await fetchZoteroItems(config);
                    for (const item of items) {
                        if (!item) {
                            continue;
                        }
                        if (item.key) {
                            zoteroByKey.set(item.key, item);
                        }
                        const doi = normalizeDoi(item.data && (item.data.DOI || item.data.doi));
                        if (doi) {
                            zoteroByDoi.set(doi, item);
                        }
                    }
                } catch (error) {
                    console.warn('Unable to fetch Zotero items for references:', error);
                }
            }

            section.innerHTML = '<h2>References</h2>';
            const ol = document.createElement('ol');

            for (const ref of citations) {
                const li = document.createElement('li');

                let item = null;
                if (ref.type === 'zotero') {
                    item = zoteroByKey.get(ref.id) || null;
                } else if (ref.type === 'doi') {
                    item = zoteroByDoi.get(ref.id) || null;
                }

                if (item && typeof item.bib === 'string' && item.bib.trim()) {
                    li.innerHTML = item.bib;
                } else if (ref.type === 'doi') {
                    const href = doiToUrl(ref.id);
                    li.innerHTML = href ? `<a href="${href}" target="_blank" rel="noopener noreferrer">${ref.id}</a>` : ref.id;
                } else if (ref.type === 'zotero') {
                    li.innerHTML = `<a href="library.html#z-${ref.id}" target="_blank" rel="noopener noreferrer">${ref.id}</a>`;
                } else {
                    li.textContent = String(ref.id || '');
                }

                const linksDiv = document.createElement('div');
                linksDiv.className = 'ref-links';

                if (ref.type === 'zotero') {
                    const a = document.createElement('a');
                    a.href = `library.html#z-${ref.id}`;
                    a.target = '_blank';
                    a.rel = 'noopener noreferrer';
                    a.textContent = 'Library';
                    linksDiv.appendChild(a);
                }

                if (ref.type === 'doi') {
                    const href = doiToUrl(ref.id);
                    if (href) {
                        const a = document.createElement('a');
                        a.href = href;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        a.textContent = 'DOI';
                        linksDiv.appendChild(a);
                    }
                } else if (item && item.data) {
                    const urlHref = normalizeExternalUrl(item.data.url || '');
                    const doiHref = doiToUrl(item.data.DOI || item.data.doi || '');
                    if (urlHref && urlHref !== doiHref) {
                        const a = document.createElement('a');
                        a.href = urlHref;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        a.textContent = 'URL';
                        linksDiv.appendChild(a);
                    }
                    if (doiHref) {
                        const a = document.createElement('a');
                        a.href = doiHref;
                        a.target = '_blank';
                        a.rel = 'noopener noreferrer';
                        a.textContent = 'DOI';
                        linksDiv.appendChild(a);
                    }
                }

                if (linksDiv.childNodes.length > 0) {
                    li.appendChild(linksDiv);
                }

                ol.appendChild(li);
            }

            section.appendChild(ol);
        }

        async function loadEntry() {
            const params = new URLSearchParams(window.location.search);
            const entryPath = params.get('entry');

            if (!entryPath) {
                document.getElementById('content').innerHTML = '<p style="color: #888;">No entry specified.</p>';
                clearReferences();
                return;
            }

            try {
                // For GitHub Pages, we need to fetch from raw.githubusercontent.com
                let fetchUrl = entryPath;
                if (window.location.hostname === 'jswachter.github.io') {
                    // Extract just the filename from the path
                    const filename = entryPath.split('/').pop();
                    fetchUrl = `https://raw.githubusercontent.com/jswachter/jswachter.github.io/main/notebooks/${filename}`;
                }

                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    throw new Error(`Fetch failed (${response.status})`);
                }
                const text = await response.text();

                // Parse frontmatter
                const lines = text.split('\n');
                let title = '';
                let date = '';
                let contentStart = 0;

                if (lines[0] === '---') {
                    let i = 1;
                    while (i < lines.length && lines[i] !== '---') {
                        if (lines[i].startsWith('title:')) {
                            title = lines[i].substring(6).trim();
                        } else if (lines[i].startsWith('date:')) {
                            date = new Date(lines[i].substring(5).trim()).toLocaleDateString('en-US', {
                                year: 'numeric',
                                month: 'long',
                                day: 'numeric'
                            });
                        }
                        i++;
                    }
                    contentStart = i + 1;
                }

                // Update page title
                if (title) {
                    document.title = title + ' - Notebook';
                }

                // Show metadata
                const metadataDiv = document.getElementById('entry-metadata');
                if (date) {
                    metadataDiv.innerHTML = `<p class="entry-date">${date}</p>`;
                }

                // Render markdown content
                const markdownContent = lines.slice(contentStart).join('\n');
                const htmlContent = marked.parse(markdownContent);
                const contentEl = document.getElementById('content');
                contentEl.innerHTML = htmlContent;

                const citations = extractCitationsAndRewriteLinks(contentEl);
                renderReferences(citations);
            } catch (error) {
                console.error('Error loading entry:', error);
                document.getElementById('content').innerHTML = '<p style="color: #888;">Unable to load entry.</p>';
                clearReferences();
            }
        }

        // Load entry when page loads
        loadEntry();
    </script>
</body>
</html>
